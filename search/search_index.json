{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Still.js Framework","text":"Still.js is a modern frontend framework that enables developers to write and reuse Vanilla JavaScript while providing a modular and component-based architecture similar to React, Angular, and VueJS. It offers a lightweight yet powerful approach to structuring applications, allowing for better maintainability and scalability without introducing a complex abstraction layer. With StillJS, you get the flexibility of raw JavaScript while benefiting from an organized and efficient development workflow.     <p>     A limitted set of resources a features are provided by still.js, yet those resources offer a complete and transversall capabilities for building Web Applications frontend from the very simple ones, to the most complex ones, follo the list of features in summary:     </p> Component Base UI,         HTML Base template,         Built-in notations/directives,         User permission flow,         Component State Management,         Global state management ,         Routing ,         Form validation ,         Web component ,         Built-in annotations"},{"location":"#microfrontend-disruptivelly","title":"Microfrontend Disruptivelly","text":"<p>One particular aspect of Still.js is the capabilities it provides to create microfronted in a disruptive way, means, we can embed Still.js component in our existing application, but, such component can be a whole front end providing access to all kind of features including navigation.</p>"},{"location":"#annotation-based","title":"Annotation Based","text":"<p>Still.js is built entirely on vanilla JavaScript, no builder or bundler are used. It introduces a unique approach to annotations by leveraging JSDoc and JavaScript comments, not for documentation but to dynamically add features at runtime.</p>"},{"location":"#typing","title":"Typing","text":"<p>Still.js uses JSDoc for typing and type hinting, enabling most TypeScript features. However, typing is generally optional, except in specific cases where it's required.</p>"},{"location":"components-communication/","title":"Inter Communication","text":"<p>Work in Progress</p> <p>Thee is yet a work in progress in this documentation, it means that some addiotnal content, scenarios and example are yet to be brought, nevertheless the current content cover from the basics to more elaborated scenarios.</p> <p>ViewComponent and BaseService import in CDN/Lone component mode</p> <p>The import (e.g. <code>import { ViewComponent } from \"@still/component/super/ViewComponent.js\"</code>) of ViewComponent and BaseService classes is inexistent CDN mode setup, as this is already provided by CDN itself.</p> <p></p>"},{"location":"components-communication/#overview","title":"Overview","text":"<p>In order to provide ways from components to communicate to each other, Still.js provade with different options thereby covering all scenarios such as Parent to child, Sibling to Sibling, any component to any other(s), follow the documentation.</p> <p></p>"},{"location":"components-communication/#1-parent-to-child-change-subscription-using-proxy-pubsub","title":"1. Parent to child change Subscription using Proxy (Pub/Sub)","text":"<p>State Subscription is a way for one Component to listen to another component State changes by subcribing to it. follow the example:</p> BiddingDisplay.jsBidOffersComponent.jsBiddersList.js Project folder structure This is the parent component<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\nimport { BidOffersComponent } from \"./BidOffersComponent.js\";\n\nexport class BiddingDisplay extends ViewComponent {\n\n    isPublic = true;\n\n    /** @Proxy @type { BidOffersComponent } */\n    bidOfferProxy; //This is assignet in the proxy prop of the &lt;st-element&gt; line 14\n\n    template = `\n        &lt;st-element \n            component=\"BidOffersComponent\"\n            proxy=\"bidOfferProxy\"\n        &gt;\n        &lt;/st-element&gt;\n        &lt;st-element component=\"BiddersList\"&gt;&lt;/st-element&gt;\n    `;\n\n    /** Component Hook which takes place when it's completly render and startder */\n    stAfterInit() {\n        /** This is needed so parent component only try to subscribe to state \n         * after child is completly loaded */\n        this.bidOfferProxy.on('load', () =&gt; {\n            // This proxy represents BidOffersComponent component\n            this.bidOfferProxy.offerAmmount.onChange((value) =&gt; {\n                console.log(`Theres is a new offer of ${value}`);\n            });\n        });\n    }\n\n}\n</code></pre> This child component has a proxy in the parent<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class BidOffersComponent extends ViewComponent {\n\n    isPublic = true;\n\n    offerAmmount = 0;\n\n    template = `\n        &lt;button (click)=\"increase()\"&gt;Increase my offer&lt;/button&gt;\n        I'm willing to offer @offerAmmount.\n    `;\n\n    /* Child component updates itself, but parent classe \n     * can also call this method thereby beng able to update\n     * the child value \n     * */\n    increase(){\n        this.offerAmmount = this.offerAmmount.value + 5;\n    }\n\n}\n</code></pre> <pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class BiddersList extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        &lt;p&gt;Here goes the list of bidders.&lt;/p&gt;\n    `;\n\n}\n</code></pre> Project folder structure<pre><code>project-root-folder\n|___@still\n|___app\n|    |\n|    |__components\n|    |   |__bidding\n|    |   |   |__BiddingDisplay.js\n|    |   |   |__BidOffersComponent.js\n|    |   |   |__BiddersList.js\n|    |   |   |\n|__app-setup.js\n|__ ...\n</code></pre> <p>Proxy approach consideration</p> <p>Parent component can Subscribe to its childrens State through 2 means, the <code>@Proxy</code> way, and/or the reference (<code>ref</code>) way.</p> <ul> <li> <p>For using a proxy, the Parent component needs to create a property annotated with both <code>@Proxy</code> and <code>@type</code> annotation, and <code>@Proxy</code> comes first, the type will be the component class which the Proxy represents.</p> </li> <li> <p>Proxy readiness is needed to subscribe to its state, in this case subscription happens when child component is fully ready, hence we're doing <code>this.bidOfferProxy.on('load', callBackFunction)</code> which is placed in the stAfterInit() Hook, and my callBackFunction is where I implement the state subscription itself.</p> </li> <li> <p>Parent can access anything which is public from the Proxy property as shown in line 25, therefore, to subscribe to a State of the child, we only need to specify <code>.onChange()</code> that which recieves a closure/function, this closure recieves the new values as first parameter.</p> </li> <li> <p>A component can subscribe to change to itself, therefore this is automatically done when the State is bound to the template, in addition to that, it can also be done through the <code>.onChange()</code> method, and this is done by using the stAfterInit() Hook as well.</p> </li> </ul> <p></p> <p></p>"},{"location":"components-communication/#2-adjacent-sibling-components-reactive-communication-using-reference-pubsub","title":"2. Adjacent (sibling) components reactive communication using Reference (Pub/Sub)","text":"<p>State Subscription is a way for one Component to listen to another component State changes by subcribing to it. follow the example:</p> BiddingDisplay.jsBidOffersComponent.jsBiddersList.js Project folder structure This is the parent component<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class BiddingDisplay extends ViewComponent {\n\n    isPublic = true;\n\n    template = `\n        &lt;st-element \n            component=\"BidOffersComponent\"\n            ref=\"BidOffersDisplayRef\"\n        &gt;\n        &lt;/st-element&gt;\n        &lt;st-element component=\"BiddersList\"&gt;&lt;/st-element&gt;\n    `;\n\n}\n</code></pre> This child component has a ref stated in the parent<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class BidOffersComponent extends ViewComponent {\n\n    isPublic = true;\n    totalBidders = 0;\n\n    template = `\n        Total bidders now is @totalBidders.\n    `;\n\n    /* Child component updates itself, but parent and sibling classe can \n    * also call this method thereby beng able to update the child value \n    * */\n    onNewBiderEntering() {\n        console.log(`New bidder enter to the list and his bid is 0 for now`);\n    }\n\n}\n</code></pre> This child component access his sibling through the reference<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\nimport { BidOffersComponent } from \"./BidOffersComponent.js\";\n\nexport class BiddersList extends ViewComponent {\n\n    isPublic = true;\n\n    /** @Prop @type { BidOffersComponent } */\n    bidOfferInstance;\n\n    template = `\n        Here goes the list of bidders.\n        &lt;button (click)=\"addBidder()\"&gt;Admit new Bidder&lt;/button&gt;\n    `;\n\n    constructor() {\n        super(); //Supper is needed to be called according to JavaScript standards\n\n        // stWhenReady() Hook detects when the sibling component is available\n        this.stWhenReady(() =&gt; {\n            // Assigning the sibling instance to the property\n            this.bidOfferInstance = Components.getFromRef('BidOffersDisplayRef');\n        });\n\n    }\n\n    addBidder() {\n        // Call sibling component method\n        this.bidOfferInstance.onNewBiderEntering();\n\n        // Updating the sibling component State through the reference\n        const prevTotalBidders = this.bidOfferInstance.totalBidders.value;\n        this.bidOfferInstance.totalBidders = prevTotalBidders + 1;\n    }\n\n}\n</code></pre> Project folder structure<pre><code>project-root-folder\n|___@still\n|___app\n|    |\n|    |__components\n|    |   |__bidding\n|    |   |   |__BiddingDisplay.js\n|    |   |   |__BidOffersComponent.js\n|    |   |   |__BiddersList.js\n|    |   |   |\n|__app-setup.js\n|__ ...\n</code></pre> <p>Reference (ref) approach consideration</p> <ul> <li> <p>Just like the <code>@Proxy</code>, reference (<code>ref</code>) way needs to be defined in the tag itself, which then makes it available to be accessed through the Components.ref() method as we can see in the second sibling ( BiddersList ).</p> </li> <li> <p>Proxies and references are alike except for the scope they can be accessed, as Proxy only the Father can acces it (see proxy example), and the reference can be access by any component as long as it's sibling or active in the same moment, therefore, Parent component can access child through reference the same way the sibling does.</p> </li> </ul> <p></p> <p></p>"},{"location":"components-communication/#3-global-state-management-reactively-components-communication-with-service","title":"3. Global state management Reactively - Components communication with Service","text":"<p>Services is another way of providing component communication capabilities, in this case, the service is not tied to any component, which means that state will remain even if some component was unloaded, follow the code example:</p> BiddingDisplay.jsBidOffersComponent.jsBiddersList.jsBiddingService.jsapp-setup.js Project folder structure This is the parent component<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\nimport { BiddingService } from \"../../service/BiddingService.js\";\n\nexport class BiddingDisplay extends ViewComponent {\n\n    isPublic = true;\n\n    /** Service declaration, will get injected automatically from the service\n     *  path defined in the application level (StillAppSetup) in app-setup.js (last tab)\n     * @Inject\n     * @type { BiddingService } */\n    bService;\n\n\n    template = `\n        &lt;st-element component=\"BiddersList\"&gt;&lt;/st-element&gt;\n        &lt;st-element \n            component=\"BidOffersComponent\"\n        &gt;\n        &lt;/st-element&gt;\n    `;\n\n    /** Component Hook which takes place when it's completly render and startder */\n    stAfterInit() {\n        /** This is needed so parent component only try to subscribe to state \n         * after child is completly loaded */\n        this.bService.on('load', () =&gt; { //Check service readiness\n            //Bellow, it Subscribe to ServiceEvent variable (countryStore)\n            this.bService.countryStore.onChange(newValue =&gt; {\n                console.warn(`New country entered the Bid, follow the list: `, newValue);\n            });\n        });\n\n    }\n\n}\n</code></pre> This child component has a ref stated in the parent<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\nimport { BiddingService } from \"../../service/BiddingService.js\";\n\nexport class BidOffersComponent extends ViewComponent {\n\n    isPublic = true;\n\n    /** @Inject @type { BiddingService } */\n    bService;\n\n    template = `\n        &lt;p&gt;\n            &lt;button (click)=\"exitTheBid()\"&gt;Exit the bidding&lt;/button&gt;\n        &lt;/p&gt;\n    `;\n\n    exitTheBid() {\n        let countryStore = this.bService.countryStore.value;\n        const myCountry = 'Australia';\n\n        // Filter out every country but Australia\n        countryStore = countryStore.filter(country =&gt; country != myCountry);\n\n        // Update the store with Australia removed from the list\n        this.bService.countryStore = countryStore;\n    }\n\n}\n</code></pre> This child component access his sibling through the reference<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\nimport { BiddingService } from '../../service/BiddingService.js';\n\nexport class BiddersList extends ViewComponent {\n\n    isPublic = true;\n\n    /** \n     * @Inject\n     * @type { BiddingService } */\n    bService;\n\n    /** Not a state but a prop, hence the annotation\n     * @Prop */\n    countriesList = ['Bulgaria', 'Canada', 'Denmark', 'Ethiop', 'France', 'Ghana']\n\n    template = `\n        &lt;p&gt;Here goes the list of bidders.&lt;/p&gt;\n        &lt;button (click)=\"addMoreCountry()\"&gt;Adde new country&lt;/button&gt;\n    `;\n\n    addMoreCountry() {\n        /** Retrieve and log the current/initial state */\n        const countryState = this.biddingService.countryStore.value;\n        console.log(`----&gt; Country Store before updating: `, countryState);\n\n        /** Get the next country from the  */\n        const newCountry = this.countriesList[countryState.length - 1];\n        /** Updating the store and re-assigning it to the service */\n        countryState.push(newCountry);\n        this.biddingService.countryStore = countryState;\n\n        /** Retrieve and log the state after update from store */\n        const updatedCountryState = this.biddingService.countryStore.value;\n        console.log(`----&gt; Country Store after updating: `, updatedCountryState);\n    }\n}\n</code></pre> Service Path is defined in StillAppSetup class<pre><code>import { BaseService, ServiceEvent } from \"../../@still/component/super/service/BaseService.js\";\n\nexport class BiddingService extends BaseService {\n\n    /** An array with a single country is being assigner */\n    countryStore = new ServiceEvent(['Australia']);\n\n}\n</code></pre> Definition of the service folder<pre><code>import { StillAppMixin } from \"./@still/component/super/AppMixin.js\";\nimport { Components } from \"./@still/setup/components.js\";\nimport { AppTemplate } from \"./app-template.js\";\nimport { HomeComponent } from \"./app/home/HomeComponent.js\";\n\nexport class StillAppSetup extends StillAppMixin(Components) {\n\n    constructor() {\n        super();\n        this.setHomeComponent(HomeComponent);\n        //service is the name of the folder where services will be placed\n        this.setServicePath('service/')\n    }\n\n    async init() {\n        return await AppTemplate.newApp();\n    }\n\n}\n</code></pre> Project folder structure<pre><code>project-root-folder\n|___@still\n|___app\n|    |\n|    |__components\n|    |   |__bidding\n|    |   |   |__BiddingDisplay.js\n|    |   |   |__BidOffersComponent.js\n|    |   |   |__BiddersList\n|    |   |   |\n|    |__service\n|    |   |__BiddingService.js\n|    |   |\n|__app-setup.js\n|__ ...\n</code></pre> <p>Still.js Service considerations</p> <ul> <li> <p>Services are singleton and for them to be injected we use the <code>@Inject</code> annotation which can also be combined with <code>@ServicePath</code> annotation allowing for specification of the service file path, also, it's required to define the injection <code>@type</code> just like we do for a Proxy.</p> </li> <li> <p>Just the same as <code>@Proxy</code>, Service need to be ready to be used, then again we call the the serviceName.on('load', callBackFunc), where serviceName is the variable name annotated with <code>@Inject</code>.</p> </li> <li> <p>The concept behind the service is that it can be composed by different type of features such as store/ServiceEvent, regular state and methods (e.g. to implement API call or complex logic implementation), for this example only ServiceEvent/Store is being used.</p> </li> <li> <p>ServiceEvent variable in the Service are the ones which allow for reactive behavior through the means os subscription the same way it happens with component state.</p> </li> </ul> <p></p>"},{"location":"components-communication/#31-defining-service-path-using-servicepath-annotation","title":"3.1. Defining Service path using @ServicePath annotation","text":"<p>For the sake of peculiar kind of organization of project structure, Still.js provides with @ServicePath annotation which allow for specification of the folder path in which the injecting service is located:</p> BiddingDisplay.jsBiddersList.jsCustomersService.js Project folder structure This is the parent component which subscribe to the service store<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nimport { CustomersService } from \"../../service/api/CustomersService.js\";\nexport class BiddingDisplay extends ViewComponent {\n\n    isPublic = true;\n\n    /** Service declaration, will get injected automatically due to Inject anottation\n     *  from the specified ServicePath path due to the annotation\n     * @Inject\n     * @ServicePath service/api/\n     * @type { CustomersService } */\n    custService;\n\n    template = `\n        &lt;st-element component=\"BiddersList\"&gt;&lt;/st-element&gt;\n    `;\n\n    /** Component Hook which takes place when it's completly render and startder */\n    stAfterInit() {\n\n        this.custService.on('load', () =&gt; { //Check service readiness\n            //Bellow, it Subscribes to ServiceEvent variable (totalCustomers)\n            this.custService.totalCustomers.onChange(newValue =&gt; {\n                console.log(`Total customer was updated to: `, newValue);\n            });\n        });\n\n    }\n\n}\n</code></pre> This is the parent component which subscribe to the service store<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\nimport { CustomersService } from '../../service/api/CustomersService.js'\n\nexport class BiddersList extends ViewComponent {\n\n    isPublic = true;\n\n    /** Parameter after sertice path is infact the folder\n     *  where it's (CustomersService.js) placed\n     * @Inject\n     * @ServicePath service/api/\n     * @type { CustomersService } */\n    customerService;\n\n    template = `\n        &lt;p&gt;Here goes the list of bidders.&lt;/p&gt;\n        &lt;button (click)=\"updateTotalCustomer()\"&gt;Up customers&lt;/button&gt;\n    `;\n\n    updateTotalCustomer() {\n        const currentValue = this.customerService.totalCustomers.value;\n        /** Update the value of the of the Store variable in the service */\n        this.customerService.totalCustomers = currentValue + 10;\n    }\n}\n</code></pre> This is the parent component which subscribe to the service store<pre><code>import { BaseService, ServiceEvent } from '../../../@still/component/super/service/BaseService.js';\nexport class CustomersService extends BaseService {\n\n    totalCustomers = new ServiceEvent(0);\n\n}\n</code></pre> Project folder structure<pre><code>project-root-folder\n|___@still\n|___app\n|    |\n|    |__components\n|    |   |__bidding\n|    |   |   |__BiddingDisplay.js\n|    |   |   |__BiddersList.js\n|    |   |   |\n|    |__service\n|    |   |__api\n|    |   |   |__CustomersService.js\n|    |   |   |\n|__app-setup.js\n|__ ...\n</code></pre> <p> In addition the the different component intecommunication approached in thispage, Still.js also provide Parent to Child communication approach which allowpassing properties and methods from parent to child as explained in the Component to Component communication.  </p>"},{"location":"components-nesting-3%2B/","title":"Multi level (3+) nesting","text":""},{"location":"components-nesting-3%2B/#multi-level-nesting-component-with-3-offsprings","title":"Multi-level nesting component with 3+ offsprings","text":"<p>Work in Progress - Coming Soon</p> <p>We're still preparing and elaborating the content which will be part of this page, please just be a bit patient, It'll be here soon.</p> <p></p>"},{"location":"components-private/","title":"Private Components","text":""},{"location":"components-private/#private-component","title":"Private Component","text":"<p>Work in Progress - Coming Soon</p> <p>We're still preparing and elaborating the content which will be part of this page, please just be a bit patient, It'll be here soon.</p> <p></p>"},{"location":"components/","title":"Fundamentls","text":"<p>Work in Progress</p> <p>Thee is yet a work in progress in this documentation, it means that some addiotnal content, scenarios and example are yet to be brought, nevertheless the current content cover from the basics to more elaborated scenarios.</p> <p>ViewComponent and BaseService import in CDN/Lone component mode</p> <p>The import (e.g. <code>import { ViewComponent } from \"@still/component/super/ViewComponent.js\"</code>) of ViewComponent and BaseService classes is inexistent CDN mode setup, as this is already provided by CDN itself.</p> <p></p>"},{"location":"components/#overview","title":"Overview","text":"<ul> <li> <p>In Still.js Component is a way of handling just anything that results in a UI out put, can be a whole page/UI, a widget, an autonomos application part (e.g. Form, Grid, Datatable, Button, etc.), or even whole application (Micro-Fronted which can be put inside a regular page or HTML), plus, it can be resuable and navegable (in case of UI/page components).</p> </li> <li> <p>The component anatomy normally consider 2 required aspects, first it has to extend from ViewComponent and second it has to define the template variable which will be used to render the visual part of it, in some situations, a third aspect is to be taken into consideration which is the constructor definition (in case there is something we want to run when starting running the component) which in turn requires the super() method from parent class (.e.g ViewComponent, BaseService) to be called inside.</p> </li> </ul> <p>Since Still.js is based on Vanilla Web Technologies (HTML, CSS and JavaSCript) the content of the template variable will naturally be pure HTML, a defined WebComponent, a set of  or a combination of any or all of them."},{"location":"components/#1-simple-example","title":"1. Simple example","text":"HomeComponent.js HomeComponent.js<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class HomeComponent extends ViewComponent {\n\n    /** Need in any component as long as not dealing with parts \n     * only accessible in case of authenticated user\n     * */\n    isPublic = true;\n\n    /**\n     * constructor for still.js might be needed in very specific\n     * situations (e.g. for using whenReady hook)\n    */\n    constructor() {\n        super();\n    }\n}\n</code></pre> <p>Conceptually, all components extends from ViewComponent, and, behide the, therefore, such extending component can serve as a whole page or a simple part of a specific page.</p> <p></p>"},{"location":"components/#component-creation","title":"Component Creation","text":"<ul> <li> <p>The recommended way fo Component creation is by using the still-cli utility (@stilljs/cli on npm), for that we run the command as follow:</p> <p><code>npx still create component path/to/MyComponentName</code></p> <p></p> </li> <li> <p>The create command for component options also provides with aliases, in this case we can abbreviate both the comand and the type of object to be created (component in this case):</p> <p><code>npx st c cp path/to/UserDataTable</code></p> <p> In the above example, you'll be creating a component with name UserDataTable in the specified path, there is no need to create he folders and sub-folders, as in case they don't exist it'll get created.</p> </li> </ul> <p></p>"},{"location":"components/#component-required-variables-reserved-for-the-framework","title":"Component required variables (Reserved for the Framework)","text":"<ul> <li> <p>isPublic - This states if the component can be accessed without authentication or not.</p> </li> <li> <p>template - Declares the UI itself by using differnt murkups (HTML, Still elements, Web-Component) and stilesheets (CSS). Not declaring it will make the component not to load.</p> </li> </ul> <p>In adition to isPublic and template, there are other features which can be used inside the javaScript part of the component such as the special method/Hooks (see hooks section), follow an example:</p> Defining Properties and States UserForm.js<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class UserForm extends ViewComponent {\n\n    isPublic = true;\n\n     template = `\n        &lt;section&gt;\n            &lt;article&gt;\n                &lt;header&gt;This is my title&lt;/header&gt;\n                &lt;div&gt;\n                    My article content with relevant summary\n                &lt;/div&gt;\n                &lt;button&gt;Learn more&lt;/botton&gt;\n            &lt;/article&gt;\n        &lt;/section&gt;\n     `;\n}\n</code></pre> <p>The template (HTML) content will be display accordingly once the template as rendered. Again, template can also contain Web-component and/or Still component which would be a child component in this case.</p> <p></p>"},{"location":"components/#2-component-state-vs-property","title":"2. Component State vs Property","text":"<p>Those are 2 of the existing ways for the component to hold data, therefore, they serve different purpose, as State is reactive and takes affect on the component lifecycle, whereas Property does not. Follow the example:</p> Defining Properties and States UserForm.js<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class UserForm extends ViewComponent {\n\n    isPublic = true;\n\n    /* Those states and have\n     * reactive feature/behavior */\n    firstName;\n    age;\n    gender;\n    department;\n\n    /* Those Property, they have to be annotated with @Prop and anotation\n     * ca be in the same or in a different line as the property itself */\n    /** @Prop */ \n    showCredentialsTab = false;\n\n    /** @Prop */ \n    myHtmlContainerId;\n\n    /** @Prop */ saveButtonLabl = 'Save User';\n\n    printUserFirstName(){\n        console.log(this.firstName.value);\n    }\n\n    assigneUserFirstName(newName){\n        this.firstName = newName;\n    }\n\n    printContainerId(){\n        console.log(this.myHtmlContainerId)\n    }\n\n}\n</code></pre> <p>When it comes to retrieve the value from a property we need to reference the <code>.velue</code> (line 25), but this is not the case for property (line 33). </p> <p>To listen to a State change reactively, some ways are provided, but more recurrent are binding it to the template, and subscribing to it as follows in the side code snippets:</p> Listening to changes ButtonComponent.js<pre><code>template = `\n    &lt;div&gt;User Name: @firstName\n    &lt;button&gt; @saveButtonLabl &lt;/button&gt;\n`\n\n/** This is a Special method/Hook which can be declared in the component */\nstAfterInit(){\n    this.firstName.onChange(newValue =&gt; {\n        console.log(`User first name changed to ${newValue}`);\n    });\n}\n</code></pre> <p>A component can subscribe to itself just like any other component can as we see in the lines 8 to 10, therefore, a good place to declare subsription is in a Hook method like stAfterInit.</p> <p></p>"},{"location":"components/#3-nested-component","title":"3. Nested Component","text":"<p>It's possible to put one component inside another, nevertheless, in order to guarantee the better performance, Still.js only allow 2 levels of nested component as follow:</p> Parent ComponentChild ComponentAnother Child Component BiddingDisplay.js<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class BiddingDisplay extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        &lt;st-element component=\"BidOffersComponent\"&gt;&lt;/st-element&gt;\n        &lt;st-element component=\"BiddersList\"&gt;&lt;/st-element&gt;\n    `;\n\n}\n</code></pre> BidOffersComponent.js<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class BidOffersComponent extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        Hhere I'll have my code which provide the UI output concerning\n        the offfers of the Bid.\n    `;\n\n}\n</code></pre> BiddersList.js<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class BiddersList extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        Here goes the list of bidders.\n    `;\n\n}\n</code></pre> <p>Above we have to parent component, which has one level of offsprings, additional level is not allowed using <code>&lt;st-element&gt;&lt;/st-element&gt;</code>, anyway it can be achieved by using Web-component or regular HTML. (see best preactices sectio).</p> <p>Nesting Component considerations</p> <p>Unlike Still.js component, Web-component and HTML tags are handled directly by the Browser, which means less burden and more performant UI, therefore, the concept in Still.js is that you have to design well the component and use &lt;st-element&gt;&lt;/st-element&gt; to handle the complex parts of your UI, and 3+ level of nested component for dealing with visual/formating aspects, this definitely will guarantee better performance.</p> <p></p> <p></p>"},{"location":"components/#4-component-to-component-communication","title":"4. Component to Component communication","text":"<p>Covering from the most basic to the most complex scenarios, Still.js provides wide different means of providing communication from component to component (e.g. Parent to child, Sibling to Sibling, any component to any other(s)). (see to the Component Communication for more details)</p> <p></p>"},{"location":"components/#parent-to-child","title":"Parent to Child","text":"Parent ComponentChild Component BiddingDisplay.js<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class BiddingDisplay extends ViewComponent {\n\n    isPublic = true;\n\n    template = `\n        &lt;st-element \n            component=\"BidOffersComponent\"\n            hieghestOffer=\"30\"\n            leadBidderName=\"Gregor\"\n        &gt;&lt;/st-element&gt;\n    `;\n}\n</code></pre> BidOffersComponent.js<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class BidOffersComponent extends ViewComponent {\n\n    isPublic = true;\n\n    hieghestOffer = 0;\n    leadBidderName = null;\n\n    template = `\n        &lt;span&gt;Hier Offer&lt;/span&gt; @hieghestOffer\n        &lt;span&gt;The leading Bidder is @leadBidderName&lt;/span&gt;\n    `;\n\n}\n</code></pre> <p>Parent component is passing 2 (hieghestOffer, leadBidderName) properties  when referencing the child, those are states variables in the child whichwill be overriden.</p> <p>Just like it's possible to update child state by passing if as property in <code>&lt;st-element&gt;</code> tag, we can also pass method as follow:</p> Parent ComponentChild Component BiddingDisplay.js<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class BiddingDisplay extends ViewComponent {\n\n    isPublic = true;\n\n    template = `\n        &lt;st-element \n            component=\"BidOffersComponent\"\n            hieghestOffer=\"30\"\n            leadBidderName=\"Gregor\"\n            (myMethodSignature)=\"alertMyChild()\"\n        &gt;&lt;/st-element&gt;\n    `;\n\n    alertMyChild(){\n        alert('Hello my child')\n    }\n}\n</code></pre> BidOffersComponent.js<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class BidOffersComponent extends ViewComponent {\n\n    isPublic = true;\n\n    hieghestOffer = 0;\n    leadBidderName = null;\n\n    template = `\n        &lt;span&gt;Hier Offer&lt;/span&gt; @hieghestOffer\n        &lt;span&gt;The leading Bidder is @leadBidderName&lt;/span&gt;\n        &lt;button (click)=\"myMethodSignature()\"&gt;Call Parent Function&lt;/button&gt;\n    `;\n\n\n    myMethodSignature(){}\n\n}\n</code></pre> <p>Unlike state and property variables, method on the <code>&lt;st-element&gt;</code> component need to be references in paranthesis (), also, normally in the child we'll have the method signature, nevertheless we can also have it's own scope.</p> <p>It's also possible for the child to pass values to parent when executing method signature, follow the example:</p> Parent ComponentChild Component BiddingDisplay.js<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class BiddingDisplay extends ViewComponent {\n\n    isPublic = true;\n\n    template = `\n        &lt;st-element \n            (processMyData)=\"alertMyChild()\"\n        &gt;&lt;/st-element&gt;\n    `;\n\n    printChildDetailes(age, name){\n        console.log(`Hello ${name} you're ${age} years old!`)\n    }\n}\n</code></pre> <p>```js title=\"BidOffersComponent.js\" hl_lines=\"8 13\" linenums=\"1\" import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";</p> <p>export class BidOffersComponent extends ViewComponent {</p> <pre><code>isPublic = true;\n\ntemplate = `\n    &lt;button (click)=\"processMyData(30, 'John')\"&gt;\n        Call Parent Function\n    &lt;/button&gt;\n`;\n\nmyMethodSignature(age, name){}\n</code></pre> <p>}</p> <p>In addition to using <code>&lt;st-element&gt;</code> component props, there are other means available for component to component communication such as <code>Pub/Sub</code>, both <code>@Proxy</code> and <code>ref</code> which is done to through <code>&lt;st-element&gt;</code> again, and the <code>Service</code> which is a global kind. (see to the Component Communication).</p> <p></p> <p>Embieding component in you regular HTML or within other Frameworks</p> <p>When it comes to components, Still.js provides the Lone Component which only require to reference the CDN for both CSS and JavaScript files thereby not needing to create a Still.js project, therefore, this approach can be followed either for small use case as well as for complex ones such as Microfrontend. (follow do documentation here)</p> <p> </p>"},{"location":"get-start/","title":"GET STARTED","text":""},{"location":"get-start/#basic-component-sample","title":"Basic component sample","text":"<p>All components extends from ViewComponent, and whenever gets rendered in the UI/browser can be assigned to the template variable as depicted below in lines 11 to 19.</p> <p>HomeComponent.js<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class HomeComponent extends ViewComponent {\n\n    /** \n     * isPublic flag is needed for any component that is publicly accessible, therefore, \n     * when dealing with authentication and permission scenario any component requiring\n     * user permission the flag will be removed or turned to false\n     */\n    isPublic = true;\n    template = `\n        &lt;div&gt;\n            &lt;h2&gt;Hello world!&lt;/h2&gt;\n            &lt;p&gt;\n            I'm an easy component with a button\n            &lt;/p&gt;\n            &lt;button&gt;I'm a button&lt;/button&gt;\n        &lt;/div&gt;\n    `;\n\n}\n</code></pre> Run result:</p> <p></p>"},{"location":"get-start/#splitting-template-html-from-js-file","title":"Splitting Template (<code>.html</code>) from <code>.js</code> file","text":"<p>As long as both template/.html and .js files are in the same folder and have the are named similarly, we just need to remove the variable template from .js and it will be able to refer to the .html file instead. Tamplete splitting from .js file is quite usefull for complex template coding also making it more manageable and organized.</p> JavaScript fileHTML Template file SlittedComponent.js<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class SlittedComponent extends ViewComponent {\n    isPublic = true;\n}\n</code></pre> SlittedComponent.html<pre><code>&lt;div&gt;\n    &lt;h3&gt;\n        This is the header for the splitted template file\n    &lt;/h3&gt;\n    &lt;br/&gt;\n    &lt;hr/&gt;\n    &lt;br/&gt;\n    &lt;p&gt;\n        Template splitted from the .js file is quite usefull especially on \n        those situations that the template content is quite extensive, \n        normally template inside the .js file can be natually used for smaller \n        template cases.\n    &lt;/p&gt;\n&lt;/div&gt;\n</code></pre> <p>Run result:</p> <p></p>"},{"location":"get-start/#event-handling","title":"Event handling","text":"<p>For event handling, we can create a method inside the component class, then we just need to bind it to any html element by assigning it to the (click) notation/directive as follow and highlighet in lines 12 and 16 to 18:</p> <p>HomeWithEvent.js<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class HomeWithEvent extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        &lt;div&gt;\n            &lt;h2&gt;Hello world from HomeWithEvent!&lt;/h2&gt;\n            &lt;p&gt;\n            I'm an easy component with a button\n            &lt;/p&gt;\n            &lt;button (click)=\"callMe()\"&gt;I'm a button&lt;/button&gt;\n        &lt;/div&gt;\n    `;\n\n    callMe() {\n        alert(`Hi, you clicked me, I'm a button`);\n    }\n\n}\n</code></pre> Run result:</p> <p></p>"},{"location":"get-start/#state-binding-and-reactive-behavior","title":"State binding and reactive behavior","text":"<p>All dev defined variable are considered state which is managed by the components instance itself, when it comes to use it, any component calling it can use and listen to it. State binding can be achieved by using @stateVariableName inside the place where it's to be bound.</p> <p>Access to the state value is done by calling <code>.value</code> property, assigning a value is is done straight to the property itself.</p> <p>CounterComponent.js<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class CounterComponent extends ViewComponent {\n\n    isPublic = true;\n    /**\n     * This is a state since no annotation or signature is put for it\n     */\n    count = 0;\n\n    template = `\n    &lt;div&gt;\n        &lt;p&gt;\n            My counter state is @count\n        &lt;/p&gt;\n        &lt;button (click)=\"increment()\"&gt;Increment (@count)&lt;/button&gt;\n        &lt;button (click)=\"decrement()\"&gt;Decrement (@count)&lt;/button&gt;\n    &lt;/div&gt;\n    `;\n\n    increment() {\n        this.count = this.count.value + 1;\n    }\n\n    decrement() {\n        this.count = this.count.value - 1;\n    }\n\n}\n</code></pre> Run result:</p> <p></p>"},{"location":"get-start/#two-way-data-binding-and-forms","title":"Two-way data binding and Forms","text":"<p>When building a form, in several situations Two-way data binding is needed, the (value) notation/directive is provided in which we only need to assign the state in which we are binding out form input, also input needs to be wrapped by a form (&lt;form&gt;&lt;/form&gt;).</p> <p>BasicForm.js<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class BasicForm extends ViewComponent {\n\n    isPublic = true;\n    firstName = '';\n    shoeSize;\n\n    template = `\n    &lt;div&gt;\n        &lt;form&gt;\n            &lt;div class=\"form-group\"&gt;\n                &lt;label&gt;First Name&lt;/label&gt;\n                &lt;input (value)=\"firstName\" type=\"text\"  placeholder=\"Enter first name\"&gt;\n            &lt;/div&gt;\n            &lt;br/&gt;\n            &lt;div class=\"form-group\"&gt;\n                &lt;label&gt;Shoe Size&lt;/label&gt;\n                &lt;input \n                    (value)=\"shoeSize\" \n                    (validator)=\"number\" \n                    (validator-warn)=\"Invalid shoe size, number is required\"\n                    placeholder=\"Enter valid shoe size\"\n                &gt;\n            &lt;/div&gt;\n        &lt;/form&gt;\n        &lt;br/&gt;\n        &lt;p&gt;Welcome &lt;b&gt;@firstName&lt;/b&gt;&lt;/p&gt;\n        &lt;br/&gt;\n        &lt;button (click)=\"setFirstName('Michael')\"&gt;Set Michael&lt;/button&gt;\n        &lt;button (click)=\"setFirstName('Dario')\"&gt;Set Dario&lt;/button&gt;\n    &lt;/div&gt;\n    `;\n\n    /** Single line method using arrow function */\n    setFirstName = (val) =&gt; this.firstName = val;\n\n}\n</code></pre> Run result:</p> <p>Input/Form grouping Important consideration</p> <p>Still.js adopts the Bootstrap approach when it comes to form group, though it's not needed, this is quite helpfull to organizing form component by adding it (Bootstrap) as part of the project, also it helps properly handle alignment/positioning like labels and validation messages.</p> <p></p>"},{"location":"get-start/#conditional-rendering-and-conditional-hideunhide","title":"Conditional rendering and Conditional Hide/Unhide","text":"<p>By creating a variable annotated with @Prop (using JSDoc approach) we can then use this as flags (or any other application flow value) thereby being possible to assigne it on the Still.js directive, in this case to render or not, or hide/unhide (renderIf) and (showIf) notations are provided respectively.</p> <p>BasicForm.js<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class BasicConditionalView extends ViewComponent {\n\n    isPublic = true;\n\n    /**\n     * The props differ from state (which does not have any annotation)\n     * in a way that state allow to trace changes which is also useful\n     * in the component to component communication scenario in real time/reactively\n     * @Prop \n     */\n    isAdminPermisison = false;\n\n    //Annotation can be put in the same line of the prop/variable\n    /** @Prop */ shouldShowContent = true;\n\n    addLabel = 'Hide';\n    adminLabel = 'Unable';\n\n    template = `\n        &lt;div&gt;\n            &lt;div (renderIf)=\"self.isAdminPermisison\"&gt;\n                Hello, this part of the content wont be rendered since\n                the flag on (renderIf) is false, even if you click\n                in the second button which turns flag to true\n            &lt;/div&gt;\n\n            &lt;p (showIf)=\"self.shouldShowContent\"&gt;\n            If you click the button bellow this content will be unhide\n            &lt;br&gt;in case flag is true, and hidden if false\n            &lt;/p&gt;\n            &lt;button (click)=\"hideOrUnhide()\"&gt;@addLabel content&lt;/button&gt;\n            &lt;button (click)=\"renderContent()\"&gt;@adminLabel Admin&lt;/button&gt;\n        &lt;/div&gt;\n    `;\n\n    hideOrUnhide() {\n        this.addLabel = 'Hide';\n        this.shouldShowContent = !this.shouldShowContent;\n        if (!this.shouldShowContent) this.addLabel = 'Unhide';\n    }\n\n    renderContent() {\n        this.adminLabel = 'Unable';\n        this.isAdminPermisison = !this.isAdminPermisison;\n        if (this.isAdminPermisison) this.adminLabel = 'Able';\n    }\n\n}\n</code></pre> Run result:</p> <p></p>"},{"location":"get-start/#adding-css-styles","title":"Adding CSS Styles","text":"<p>Everything is base in Vanilla web technologies, therefore we can just write CSS naturally by creating the  scope, but it it also allows inline CSS if needed just like normall HTML with css in it.</p> <p>BasicForm.js<pre><code>export class FormatedDataTable extends ViewComponent {\n\n    isPublic = true;\n    template = `\n\n        &lt;style&gt;\n            ol {\n                display: table;\n                width: 98%;\n                border: 1px solid black;\n            }\n            li, ol::before { display: table-row }\n\n            ol::before { content: \"\" }\n\n            li span {\n                display: table-cell;\n                border: 1px solid black;\n                padding: 8px;\n            }\n\n            li:nth-child(odd) { background: lightgrey; }\n\n            li:first-child {\n                font-weight: bold;\n                background-color: grey;\n            }\n\n        &lt;/style&gt;\n        &lt;h2&gt;Ordered List Styled as a Table&lt;/h2&gt;\n\n        &lt;ol&gt;\n            &lt;li&gt;\n                &lt;span&gt;#&lt;/span&gt;\n                &lt;span&gt;Item&lt;/span&gt;\n            &lt;/li&gt;\n            &lt;li&gt;\n                &lt;span&gt;1&lt;/span&gt;\n                &lt;span&gt;Apple&lt;/span&gt;\n            &lt;/li&gt;\n            &lt;li&gt;\n                &lt;span&gt;2&lt;/span&gt;\n                &lt;span&gt;Banana&lt;/span&gt;\n            &lt;/li&gt;\n            &lt;li&gt;\n                &lt;span&gt;3&lt;/span&gt;\n                &lt;span&gt;Grapes&lt;/span&gt;\n            &lt;/li&gt;\n            &lt;li&gt;\n                &lt;span&gt;4&lt;/span&gt;\n                &lt;span&gt;Orange&lt;/span&gt;\n            &lt;/li&gt;\n            &lt;li&gt;\n                &lt;span&gt;5&lt;/span&gt;\n                &lt;span&gt;Mango&lt;/span&gt;\n            &lt;/li&gt;\n        &lt;/ol&gt;\n    `;\n\n}\n</code></pre> Run result:</p> <p></p>"},{"location":"get-start/#basics-of-component-embeding","title":"Basics of Component Embeding","text":"<p>Bringing a component inside another in general is achievable by using the <code>&lt;st-element&gt;&lt;/st-element&gt;</code> tag where we can then specify the component name we want to embed as child (tag property as line 16), additional child component property (e.g. lines 18 and 19) and event handlers also can be passed the same way (in the tag) as long as they child difined it.</p> Parent ComponentChild Component UserForm.js<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class UserForm extends ViewComponent {\n\n    isPublic = true;\n\n    /** @Prop */\n    childTitleState = 'Child Title from Parent';\n    changeCounter = 0;\n\n    template = `\n        &lt;button (click)=\"updateChildTitle()\"&gt;Change child title&lt;/button&gt;\n        &lt;br/&gt;\n        &lt;br/&gt;\n        &lt;st-element \n            component=\"UserGrid\"\n            ref=\"insideFormGridReference\"\n            tableTitle=\"self.childTitleState\"\n            titleMergeSize=\"5\"\n            &gt;\n        &lt;/st-element&gt;\n    `;\n\n    updateChildTitle() {\n\n        this.changeCounter = this.changeCounter.value + 1;\n\n        /** @type { UserGrid } */\n        const userGridObj = Components.getFromRef('insideFormGridReference');\n        userGridObj.tableTitle = 'Title altered ' + this.changeCounter.value + 'x';\n    }\n\n}\n</code></pre> UserGrid.js<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class UserGrid extends ViewComponent {\n\n    isPublic = true;\n\n    tableTitle = \"Users List Not changed\";\n    /** @Prop */\n    titleMergeSize;\n\n    template = `\n        &lt;table border=\"1\"&gt;\n            &lt;thead&gt;\n                &lt;tr&gt;&lt;th colspan=\"@titleMergeSize\"&gt;@tableTitle&lt;/td&gt;&lt;/tr&gt;\n                &lt;tr&gt;\n                    &lt;th&gt;ID&lt;/th&gt;\n                    &lt;th&gt;Name&lt;/th&gt;\n                    &lt;th&gt;Email&lt;/th&gt;\n                    &lt;th&gt;Age&lt;/th&gt;\n                    &lt;th&gt;Country&lt;/th&gt;\n                &lt;/tr&gt;\n            &lt;/thead&gt;\n            &lt;tbody&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;1&lt;/td&gt;\n                    &lt;td&gt;John Doe&lt;/td&gt;\n                    &lt;td&gt;john@example.com&lt;/td&gt;\n                    &lt;td&gt;28&lt;/td&gt;\n                    &lt;td&gt;USA&lt;/td&gt;\n                &lt;/tr&gt;\n                &lt;tr&gt;\n                    &lt;td&gt;2&lt;/td&gt;\n                    &lt;td&gt;Jane Smith&lt;/td&gt;\n                    &lt;td&gt;jane@example.com&lt;/td&gt;\n                    &lt;td&gt;32&lt;/td&gt;\n                    &lt;td&gt;UK&lt;/td&gt;\n                &lt;/tr&gt;\n            &lt;/tbody&gt;\n        &lt;/table&gt;\n\n    `;\n}\n</code></pre> <p>Run result:</p> <p></p>"},{"location":"get-start/#basics-of-navigation","title":"Basics of Navigation","text":"<p>Whe using still-cli (<code>@stilljs/cli</code> - which is the recommended way) to generate the component, both route name (same as component name) and component URL will be added automatically in the <code>route.map.js</code> file in the project root folder, therefore, navigation can be done the way it workes in regular web pages. in the bellow code navigation is done by using route name. </p> First ComponentSecond ComponentRouting file EntryMenu.js<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class EntryMenu extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        &lt;div&gt;\n            This is Entry menu component, press the bellow \n            &lt;br/&gt;button or in the link to navigate to User\n            &lt;br/&gt;\n            &lt;br/&gt;\n            &lt;button (click)=\"goto('UserRegistration')\"&gt;Register user&lt;/button&gt;\n        &lt;/div&gt;\n    `;\n\n}\n</code></pre> UserRegistration.js<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class UserRegistration extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        &lt;div class=\"user-reg-container\"&gt;\n            &lt;span class=\"smile-icone\"&gt;&amp;#9787;&lt;/span&gt; \n            &lt;br/&gt;\n            This is the user registration component\n            &lt;br/&gt;\n            &lt;button (click)=\"goto('EntryMenu')\"&gt;Go to Menu&lt;/button&gt;\n        &lt;/div&gt;\n\n        &lt;style&gt;\n            .user-reg-container { text-align: center; }\n            .smile-icone { \n                color: orange;\n                font-size: 60px;\n            }\n        &lt;/style&gt;\n    `;\n\n}\n</code></pre> route.map.js<pre><code>export const stillRoutesMap = {\n    viewRoutes: {\n        regular: {\n            EntryMenu: { path: \"app/components/routing\" },\n            UserRegistration: { path: \"app/components/routing\" }\n        },\n        lazyInitial: {}\n    }\n}\n</code></pre> <p>Run result:</p> <p></p>"},{"location":"get-start/#dom-manipulation","title":"DOM Manipulation","text":"<p>Because Still.js is 100% pure/Vanilla JavaScript, DOM manipulation can be done straight as the native/regular DOM API, no workaround or additional layer/special coding is needed. </p> First Component EntryMenu.js<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class LoginComponent extends ViewComponent {\n\n    isPublic = true;\n\n    userName;\n    password;\n\n    template = `\n        &lt;form onsubmit=\"return false;\"&gt;\n            &lt;div&gt;Type the same for both user and password for &lt;br&gt;success login, something else for invalid&lt;div&gt;\n\n            Username: &lt;input type=\"text\" (value)=\"userName\"&gt;\n            &lt;br&gt;&lt;br&gt;\n            Password: &lt;input type=\"password\" (value)=\"password\"&gt;&lt;br&gt;\n\n            &lt;span id=\"loginStatus\"&gt;&lt;/span&gt;&lt;br&gt;\n\n            &lt;button (click)=\"processLogin()\"&gt;Login&lt;/button&gt;\n        &lt;/form&gt;\n    `;\n\n    processLogin() {\n\n        const user = this.userName.value;\n        const password = this.password.value;\n        const messageContainer = document.getElementById('loginStatus');\n\n        if (user !== password || user == '' || password == '') {\n            /** Assignin new content via DOM manipulation */\n            messageContainer.innerHTML = 'Invalid user or password';\n            /** CSS updating through DOM */\n            messageContainer.style = 'color: red; background-color: #ab1f1f38;';\n            /** Changing inputs border via DOM manipulation */\n            document.querySelector('input[type=text]').style = 'border: 1px solid red';\n            document.querySelector('input[type=password]').style = 'border: 1px solid red';\n\n        } else {\n            /** Assignin new content via DOM manipulation */\n            messageContainer.innerHTML = 'User login success! &amp;#9787;';\n            /** CSS updating through DOM */\n            messageContainer.style = 'color: green; background-color: none;';\n            /** Changing inputs border via DOM manipulation */\n            document.querySelector('input[type=text]').style = 'border: 1px solid green';\n            document.querySelector('input[type=password]').style = 'border: 1px solid green';\n        }\n    }\n\n}\n</code></pre> <p>Run result:</p> <p></p>"},{"location":"get-start/#looping-and-rendering-from-a-list","title":"Looping and Rendering from a List","text":"<p>Lopping a list and rendering its items is quite simple, Still.js provides the (forEach) notation/directive, which can be pass to a top level container which is then used to wrap the template for the desired output of each list item. </p> Main ComponentChild Component used in the Loop LoopingDirective.js<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class LoopingDirective extends ViewComponent {\n\n    isPublic = true;\n\n    /** This is the list of products ( data source ) */\n    productList = [\n        { name: 'Orange', sold: 3, stockAvail: 7, price: '0.75$' },\n        { name: 'Apple', sold: 1, stockAvail: 5, price: '0.88$' },\n        { name: 'Banana', sold: 10, stockAvail: 50, price: '1.03$' },\n    ]\n\n    template = `\n        &lt;div&gt;\n            &lt;h5&gt;Looping with HTML child&lt;/h5&gt;\n            &lt;br&gt;\n            &lt;span (forEach)=\"productList\"&gt;\n                Stock Availability\n                &lt;div each=\"item\"&gt;\n                    &lt;b&gt;Name:&lt;/b&gt; {item.name} - &lt;b&gt;Sock:&lt;/b&gt; {item.stockAvail} - &lt;b&gt;Price:&lt;/b&gt; {item.price}\n                &lt;/div&gt;\n            &lt;span&gt;\n        &lt;/div&gt;\n\n        &lt;br&gt;&lt;hr&gt;&lt;br/&gt;\n\n        &lt;div&gt;\n            &lt;h5&gt;Looping with child Component&lt;/h5&gt;\n            &lt;br&gt;\n            &lt;span (forEach)=\"productList\"&gt;\n                Shipping Cart Checkout\n                &lt;!-- Fields are mapped one to one from data \n                    source (productList) to the child component state --&gt;\n                &lt;st-element component=\"ShoppingItem\" each=\"item\"&gt;&lt;/st-element&gt;\n            &lt;span&gt;\n        &lt;/div&gt;\n    `;\n}\n</code></pre> ShoppingItem.js<pre><code>import { ViewComponent } from \"../../../@still/component/super/ViewComponent.js\";\n\nexport class ShoppingItem extends ViewComponent {\n\n    isPublic = true;\n\n    /**\n     * Bellow states (name, sold, price) are being mapped directly since those\n     * names coincides with each item in the Data source in the parent component\n     */\n    name;\n    sold;\n    price;\n\n    template = `\n        &lt;div class=\"shoping-item-card\"&gt;\n            &lt;span&gt;Produce Name: @name&lt;/span&gt;\n            &lt;span&gt;Quantity: @sold&lt;/span&gt;\n            &lt;span&gt;Price: @price&lt;/span&gt;\n        &lt;/div&gt;\n\n        &lt;style&gt;\n            .shoping-item-card{ display: flex; }\n\n            .shoping-item-card span:first-child { width: 30%; }\n\n            .shoping-item-card span:last-child { border-right: none; }\n\n            .shoping-item-card span {\n                border-right: 1px solid black;\n                padding: 2px 5px; width: 18%;\n                text-align: center; display: block;\n            }\n        &lt;/style&gt;\n    `;\n}\n</code></pre> <p>Run result:</p> <p> </p>"},{"location":"installation-and-running-cdn/","title":"Setup OPTION 2 - Using CDN","text":""},{"location":"installation-and-running-cdn/#using-cdn-for-lone-component-andor-microfrontend","title":"Using CDN For Lone Component and/or Microfrontend","text":"<p>In the CND mode, instead of the whole folder structure, only the <code>app</code> folder and <code>router.map.js</code> file are needed, also, we need to set the path where they'll be placeed by using the <code>STILL_HOME</code> variable, follow the folder structure example as well as coding sample right after:</p> <p></p>"},{"location":"installation-and-running-cdn/#1-folder-structure","title":"1. Folder Structure","text":"Folder structure in CDN mode <pre><code>my-project-name\n|\n|_ microfronteds\n   |_ still\n      |_ app\n      |  |_ components\n      |_ route.map.js\n   |_ another-mf-provider\n</code></pre> <p>Project folder substructure considerations</p> <p>In the above example structure, we have a folder name <code>microfronted</code>, where we have the <code>still</code> sub-folder, and, we also have <code>component</code> folder inside the app root, nevertheless all 3 (microfronted, still and component) can be named as per the dev will.</p> <p></p>"},{"location":"installation-and-running-cdn/#2-basic-code-sample","title":"2. Basic code sample","text":"index.htmlCounterComponent.jsroute.map.js <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;script&gt; STILL_HOME = 'microfronteds/still/' &lt;/script&gt;\n        &lt;link href=\"https://cdn.jsdelivr.net/npm/@stilljs/core@0.0.8/@still/ui/css/stillcss\" rel=\"stylesheet\"&gt;\n        &lt;script src=\"https://cdn.jsdelivr.net/npm/@stilljs/core@0.0.8/@still/lone.js\"type=\"module\"&gt;&lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;st-element component=\"CounterComponent\"&gt;&lt;/st-element&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <pre><code>/** \n * This file will be place inside the components folder\n * according to the above folder structure \n * */\nexport class CounterComponent extends ViewComponent {\n\n    isPublic = true;\n    count = 0;\n\n    template = `\n    &lt;div&gt;\n        &lt;p&gt;My counter state is @count&lt;/p&gt;\n        &lt;button (click)=\"increment()\"&gt;Increment (@count)&lt;/button&gt;\n    &lt;/div&gt;\n    `;\n\n    increment() {\n        this.count = this.count.value + 1;\n    }\n}\n</code></pre> <pre><code>/** \n * This file will be placed in the root of app folder\n * */\nexport const stillRoutesMap = {\n    viewRoutes: {\n        regular: {\n            CounterComponent: { path: \"app/components/\" }\n        },\n        lazyInitial: {}\n    }\n}\n\n\nexport function $stillGetRouteMap() {\n    return {        route: {\n            ...stillRoutesMap.viewRoutes.regular,\n            ...stillRoutesMap.viewRoutes.lazyInitial\n        },\n    }\n}\n</code></pre> <p>We can add our components in our HTML/App (React, Angular, etc.) by using<code>&lt;st-element&gt;</code> tag instead of depending on the Still.js Application container to render the components, as it (Application container) is totally inexistent in this case.</p> <p>Component creation</p> <p>Although we don't have Still project structure in CDN mode, it's always recommended to use the still-cli to generate components, as this is the way the routes will be automatically added/managed in addition to the component generation.</p> <p>Routing and route.map.js file</p> <p>Despite Still App container is not available in the CND mode, navigation feature is still available, plus, it's needed for the framework to know how to locate the components, hence the route.map.js file.</p> <p></p>"},{"location":"installation-and-running-cdn/#3-running-the-project-in-cdn-mode","title":"3. Running the project in CDN mode","text":"<p>The proper way of running the project in the CDN mode is by having it from a web server, we'll use <code>live-server</code> in this example, for that let's first install it:</p> <pre><code>npm i -g live-server\n</code></pre> <p>Running the project from inside the project root folder ( <code>my-project-name</code> ) <pre><code>npx live-server\n</code></pre></p> <p>Run result:</p> <p></p>"},{"location":"installation-and-running-cdn/#cdn-files","title":"CDN Files","text":"JavaScript:  <pre><code>https://cdn.jsdelivr.net/npm/@stilljs/core@0.0.8/@still/lone.js\n</code></pre>  CSS:  <pre><code>https://cdn.jsdelivr.net/npm/@stilljs/core@0.0.8/@still/ui/css/still.css\n</code></pre> You're good to go! enjoy your coding."},{"location":"installation-and-running/","title":"Setup OPTION 1 - Still.js Project","text":""},{"location":"installation-and-running/#creating-a-stilljs-project","title":"Creating a Still.js Project","text":""},{"location":"installation-and-running/#1-installation","title":"1. Installation","text":"<pre><code>npm install @stilljs/cli -g\n</code></pre> <p>In pricinple, still.js application development process is tied to the NPM, therefore, for it to be available in our machine we need to make a global (-g) installation.</p> <p>Once installed, still-cli can be invoked from the terminal by typing <code>npx still</code> to see the available commands and ooptions.</p> <p></p>"},{"location":"installation-and-running/#2-creating-a-project","title":"2. Creating a project","text":"<pre><code>npx still create project project-name\n</code></pre> <p>After creating a project a new folder is created with the name that was specified.</p> <p></p>"},{"location":"installation-and-running/#3-acessing-the-project-project-structure","title":"3. Acessing the project (Project structure)","text":"<p>In the above picture we have the project structure open in the code editor, everything concerning the project will be created inside the app folder. Inicially the app folder comes with one component which path is app/home/HomeComponent.js as also depicted in the picture.</p> <p></p>"},{"location":"installation-and-running/#4-running-the-project","title":"4. Running the project","text":"<p><code>npx still app serve</code></p> <p>The above command needs to bu run in the terminal from the project folder as dipicted bellow:</p> <p></p> <p> After typing for serving the project it gets oppened automatically in the browser as in the bellow picture:</p> <p></p> You're all set! enjoy your coding. <p></p>"},{"location":"lone-component/","title":"Lone component and Microfrontend","text":""},{"location":"lone-component/#private-component","title":"Private Component","text":"<p>Work in Progress - Coming Soon</p> <p>We're still preparing and elaborating the content which will be part of this page, please just be a bit patient, It'll be here soon.</p> <p></p>"},{"location":"playground/","title":"Code Editor Example","text":"// Write your JavaScript code here..."},{"location":"routing/","title":"ROUTING","text":""},{"location":"routing/#stilljs-routing-and-routing-object","title":"StillJS Routing and Routing Object","text":""},{"location":"routing/#simple-example","title":"Simple example","text":"HomeComponent.jsUsersGridComponent.js HomeComponent.js<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\nimport { UsersGridComponent } from \"components/users/UsersGridComponent.js\";\nimport { Router } from \"../../@still/routing/router.js\";\n\nexport class HomeComponent extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        &lt;h1&gt;\n            Welcome to the main page\n        &lt;/h1&gt;\n        &lt;a (click)=\"gotoUsersGrid()\"&gt;List Users&lt;/a&gt;\n    `;\n\n    constructor() {\n        super();\n    }\n\n    gotoUsersGrid(){\n        Router.goto(UsersGridComponent);\n    }\n\n}\n</code></pre> HomeComponent.js<pre><code>import { ViewComponent } from \"../../@still/component/super/ViewComponent.js\";\n\nexport class UsersGridComponent extends ViewComponent {\n\n    isPublic = true;\n    template = `\n        &lt;h2&gt;Users Data&lt;/h2&gt;\n\n        &lt;table&gt;\n            &lt;tr&gt;\n                &lt;th&gt;ID&lt;/th&gt;\n                &lt;th&gt;Name&lt;/th&gt;\n                &lt;th&gt;Email&lt;/th&gt;\n                &lt;th&gt;Role&lt;/th&gt;\n            &lt;/tr&gt;\n            &lt;tr&gt;\n                &lt;td&gt;1&lt;/td&gt;\n                &lt;td&gt;Alice Johnson&lt;/td&gt;\n                &lt;td&gt;alice@example.com&lt;/td&gt;\n                &lt;td&gt;Admin&lt;/td&gt;\n            &lt;/tr&gt;\n            &lt;tr&gt;\n                &lt;td&gt;2&lt;/td&gt;\n                &lt;td&gt;Bob Smith&lt;/td&gt;\n                &lt;td&gt;bob@example.com&lt;/td&gt;\n                &lt;td&gt;Editor&lt;/td&gt;\n            &lt;/tr&gt;\n        &lt;/table&gt;\n    `;\n\n    constructor() {\n        super();\n    }\n\n}\n</code></pre> Routing considerations <p>For this example routing is implemented inside another method which then We're passing the component we want to navigate/go to, follow such component.</p> <p>Important consideration</p> <p>In the above code, on the HomeComponent we have the Route.goto() (line 20) being called inside the component method gotoUsersGrid(), as this method could be named anything (following  JS naming convention), nevertheless, this is then called on the template  tag (line 12), as this is the practice in StillJS.</p>"}]}